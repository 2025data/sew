<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Sew Fullscreen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#ffffff">
  <style>
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #fff;
      position: fixed;
    }
    #pad {
      display: block;
      width: 100vw;
      height: 100vh;
      touch-action: none;
      background: #fff;
      cursor: crosshair;
    }
    /* Hidden UI - shown only when tapping corner */
    #menu {
      position: fixed;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      border: 2px solid #000;
      padding: 8px;
      display: none;
      font-family: sans-serif;
      font-size: 14px;
      z-index: 1000;
    }
    #menu.visible {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: space-around;
      align-items: center;
    }
    #menu button {
      font-size: 16px;
      padding: 16px 24px;
      border: 2px solid #000;
      background: #fff;
      min-width: 80px;
      cursor: pointer;
    }
    #menu button:active, #menu button.active {
      background: #ddd;
      border-color: #333;
    }
    .weight-btn, .color-btn, .mirror-btn {
      min-width: 80px;
      padding: 16px 24px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    .weight-icon {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .weight-line {
      background: #000;
      width: 100%;
    }
    .color-swatch {
      width: 40px;
      height: 40px;
      border: 1px solid #000;
    }
    .mirror-icon {
      width: 40px;
      height: 40px;
    }
    .status {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 4px 8px;
      font-size: 12px;
      font-family: monospace;
      border-radius: 4px;
      display: none;
      z-index: 999;
    }
    .status.show {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="pad"></canvas>
  
  <div id="menu">
    <button id="clearBtn">Clear</button>
    
    <div id="weightBtns" style="display: contents;">
      <!-- Line weight buttons with visual icons -->
    </div>
    
    <div id="colorBtns" style="display: contents;">
      <!-- Color buttons with swatches -->
    </div>
    
    <div id="mirrorBtns" style="display: contents;">
      <!-- Mirror buttons with icons -->
    </div>
    
    <button id="sewBtn">Sew</button>
  </div>
  
  <div class="status" id="status"></div>

  <script>
    // Fullscreen drawing app for Kindle
    const canvas = document.getElementById('pad');
    const ctx = canvas.getContext('2d');
    const menu = document.getElementById('menu');
    const statusDiv = document.getElementById('status');
    
    // Set canvas to full screen
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Drawing state
    let isDrawing = false;
    let strokes = [];
    let currentStroke = null;
    let lineWeight = 7;
    let color = '#000000';
    let mirrorMode = 'none';
    let counter = parseInt(localStorage.getItem('sewCounter') || '1');
    
    // Available options
    const weights = [1, 2, 4, 7, 12, 20, 33, 55, 92, 153, 300];
    const colors = ['#000000', '#333333', '#666666', '#999999', '#CCCCCC', '#FFFFFF'];
    const mirrors = [
      {mode: 'none', label: '○'},
      {mode: 'bilateral', label: '◐'},
      {mode: 'quad', label: '◰'},
      {mode: 'radial', label: '✱'}
    ];
    
    // Create line weight buttons
    const weightBtns = document.getElementById('weightBtns');
    weights.forEach(w => {
      const btn = document.createElement('button');
      btn.className = 'weight-btn';
      if (w === 7) btn.classList.add('active');
      
      const icon = document.createElement('div');
      icon.className = 'weight-icon';
      
      const line = document.createElement('div');
      line.className = 'weight-line';
      line.style.height = Math.min(w, 40) + 'px';
      
      icon.appendChild(line);
      btn.appendChild(icon);
      
      btn.addEventListener('click', () => {
        lineWeight = w;
        document.querySelectorAll('.weight-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        showStatus(`Line: ${w}px`);
        menu.classList.remove('visible');
      });
      
      weightBtns.appendChild(btn);
    });
    
    // Create color buttons
    const colorBtns = document.getElementById('colorBtns');
    colors.forEach(c => {
      const btn = document.createElement('button');
      btn.className = 'color-btn';
      if (c === '#000000') btn.classList.add('active');
      
      const swatch = document.createElement('div');
      swatch.className = 'color-swatch';
      swatch.style.backgroundColor = c;
      
      btn.appendChild(swatch);
      
      btn.addEventListener('click', () => {
        color = c;
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        showStatus(`Color: ${c}`);
        menu.classList.remove('visible');
      });
      
      colorBtns.appendChild(btn);
    });
    
    // Create mirror buttons
    const mirrorBtns = document.getElementById('mirrorBtns');
    mirrors.forEach(m => {
      const btn = document.createElement('button');
      btn.className = 'mirror-btn';
      btn.textContent = m.label;
      if (m.mode === 'none') btn.classList.add('active');
      
      btn.addEventListener('click', () => {
        mirrorMode = m.mode;
        document.querySelectorAll('.mirror-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        showStatus(`Mirror: ${m.mode}`);
        redraw();
        menu.classList.remove('visible');
      });
      
      mirrorBtns.appendChild(btn);
    });
    
    // Menu toggle - tap bottom-left corner
    canvas.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      const x = touch.clientX;
      const y = touch.clientY;
      
      // Bottom-left corner (100x100px) toggles menu
      if (x < 100 && y > canvas.height - 100) {
        e.preventDefault();
        menu.classList.toggle('visible');
        return;
      }
      
      // If menu is open and tapping outside it, close menu
      if (menu.classList.contains('visible')) {
        menu.classList.remove('visible');
        return;
      }
      
      // Start drawing
      isDrawing = true;
      currentStroke = {
        points: [{x, y}],
        weight: lineWeight,
        color: color
      };
    }, {passive: false});
    
    canvas.addEventListener('touchmove', (e) => {
      if (!isDrawing || menu.classList.contains('visible')) return;
      e.preventDefault();
      
      const touch = e.touches[0];
      const x = touch.clientX;
      const y = touch.clientY;
      
      currentStroke.points.push({x, y});
      drawStroke(currentStroke);
    }, {passive: false});
    
    canvas.addEventListener('touchend', (e) => {
      if (!isDrawing) return;
      e.preventDefault();
      isDrawing = false;
      
      // If it was just a tap (single point), draw a dot
      if (currentStroke.points.length === 1) {
        const pt = currentStroke.points[0];
        const points = getMirroredPoints([pt]);
        
        ctx.fillStyle = currentStroke.color;
        points.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, currentStroke.weight / 2, 0, Math.PI * 2);
          ctx.fill();
        });
      }
      
      strokes.push(currentStroke);
      currentStroke = null;
    });
    
    // Draw a single stroke
    function drawStroke(stroke) {
      const points = getMirroredPoints(stroke.points);
      
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = stroke.weight;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      ctx.beginPath();
      points.forEach((pt, i) => {
        if (i === 0) ctx.moveTo(pt.x, pt.y);
        else ctx.lineTo(pt.x, pt.y);
      });
      ctx.stroke();
    }
    
    // Get mirrored points based on mode
    function getMirroredPoints(points) {
      if (mirrorMode === 'none') return points;
      
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const result = [...points];
      
      if (mirrorMode === 'bilateral') {
        points.forEach(p => {
          result.push({x: 2*cx - p.x, y: p.y});
        });
      } else if (mirrorMode === 'quad') {
        points.forEach(p => {
          result.push({x: 2*cx - p.x, y: p.y});
          result.push({x: p.x, y: 2*cy - p.y});
          result.push({x: 2*cx - p.x, y: 2*cy - p.y});
        });
      } else if (mirrorMode === 'radial') {
        points.forEach(p => {
          const dx = p.x - cx;
          const dy = p.y - cy;
          for (let angle = 45; angle < 360; angle += 45) {
            const rad = angle * Math.PI / 180;
            const cos_a = Math.cos(rad);
            const sin_a = Math.sin(rad);
            result.push({
              x: cx + dx * cos_a - dy * sin_a,
              y: cy + dx * sin_a + dy * cos_a
            });
          }
        });
      }
      
      return result;
    }
    
    // Redraw everything
    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      strokes.forEach(stroke => drawStroke(stroke));
      if (currentStroke) drawStroke(currentStroke);
    }
    
    // Clear canvas
    document.getElementById('clearBtn').addEventListener('click', () => {
      strokes = [];
      currentStroke = null;
      redraw();
      showStatus('Cleared');
      menu.classList.remove('visible');
    });
    
    // Save drawing
    document.getElementById('sewBtn').addEventListener('click', () => {
      const now = new Date();
      const months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
      const dateStr = `${months[now.getMonth()]} ${now.getDate()}, ${now.getFullYear()}-${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
      const filename = `${dateStr}#${pad(counter, 4)}.txt`;
      
      // Expand strokes with mirrors
      const expandedStrokes = strokes.map(stroke => ({
        color: stroke.color,
        lineWidth: stroke.weight,
        points: getMirroredPoints(stroke.points)
      }));
      
      const data = {
        canvasWidth: canvas.width,
        canvasHeight: canvas.height,
        strokes: expandedStrokes
      };
      
      // Download
      const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      
      counter++;
      localStorage.setItem('sewCounter', counter.toString());
      
      showStatus(`Saved: ${filename}`, 3000);
      menu.classList.remove('visible');
    });
    
    function pad(num, size = 2) {
      return num.toString().padStart(size, '0');
    }
    
    function showStatus(msg, duration = 2000) {
      statusDiv.textContent = msg;
      statusDiv.classList.add('show');
      setTimeout(() => statusDiv.classList.remove('show'), duration);
    }
    
    // Show initial help
    setTimeout(() => {
      showStatus('Tap bottom-left corner for menu', 3000);
    }, 500);
    
    // Prevent scrolling/zooming
    document.addEventListener('touchmove', (e) => {
      if (e.touches.length > 1) e.preventDefault();
    }, {passive: false});
    
    // Request fullscreen on load (if supported)
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen().catch(() => {});
    } else if (document.documentElement.webkitRequestFullscreen) {
      document.documentElement.webkitRequestFullscreen().catch(() => {});
    }
    
    // Force scroll to hide URL bar on Kindle/mobile browsers
    window.addEventListener('load', () => {
      setTimeout(() => {
        window.scrollTo(0, 1);
      }, 100);
    });
    
    // Hide address bar on orientation change
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        window.scrollTo(0, 1);
      }, 100);
    });
  </script>
</body>
</html>
