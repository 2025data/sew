<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Sew Fullscreen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#ffffff">
  <style>
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #fff;
      position: fixed;
    }
    #pad {
      display: block;
      width: 100vw;
      height: 100vh;
      touch-action: none;
      background: #fff;
      cursor: crosshair;
    }
    /* Hidden UI - shown only when tapping corner */
    #menu {
      position: fixed;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      border: 2px solid #000;
      padding: 8px;
      display: none;
      font-family: sans-serif;
      font-size: 14px;
      z-index: 1000;
    }
    #menu.visible {
      display: flex;
      flex-direction: row;
      gap: 8px;
      justify-content: space-around;
      align-items: center;
    }
    #menu button {
      font-size: 14px;
      padding: 10px 16px;
      border: 2px solid #000;
      background: #fff;
      cursor: pointer;
      white-space: nowrap;
      position: relative;
      overflow: hidden;
    }
    #menu button:active, #menu button.active {
      background: #ddd;
      border-color: #333;
    }
    
    /* Visual indicators on toggle buttons */
    .btn-indicator {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 1;
    }
    .btn-text {
      position: relative;
      z-index: 2;
      background: #fff;
      padding: 0 4px;
      display: inline-block;
    }
    #weightToggle .btn-text,
    #colorToggle .btn-text,
    #mirrorToggle .btn-text {
      background: rgba(255, 255, 255, 0.9);
      padding: 2px 6px;
      border-radius: 2px;
    }
    
    /* Flyout containers */
    .flyout-container {
      position: relative;
      display: inline-block;
    }
    .flyout {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-bottom: 8px;
      background: rgba(255,255,255,0.98);
      border: 2px solid #000;
      padding: 8px;
      display: none;
      flex-wrap: wrap;
      gap: 6px;
      max-width: 300px;
      justify-content: center;
    }
    .flyout.visible {
      display: flex;
    }
    
    /* Full-screen grid for line weights */
    #weightFlyout {
      position: fixed;
      top: 10px;
      left: 10px;
      right: 10px;
      bottom: 80px;
      max-width: 100%;
      transform: none;
      margin: 0;
      display: none;
      grid-template-columns: repeat(7, 1fr);
      grid-template-rows: repeat(7, 1fr);
      overflow-y: auto;
    }
    #weightFlyout.visible {
      display: grid;
    }
    
    .flyout button {
      min-width: 40px;
      padding: 6px;
      font-size: 11px;
    }
    
    .weight-icon {
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    .weight-line {
      background: #000;
      width: 100%;
    }
    .weight-label {
      position: absolute;
      background: rgba(255, 255, 255, 0.9);
      padding: 2px 4px;
      font-size: 10px;
      border-radius: 2px;
      z-index: 2;
    }
    .color-swatch {
      width: 40px;
      height: 30px;
      border: 1px solid #000;
    }
    .status {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 4px 8px;
      font-size: 12px;
      font-family: monospace;
      border-radius: 4px;
      display: none;
      z-index: 999;
    }
    .status.show {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="pad"></canvas>
  
  <div id="menu">
    <button id="clearBtn">Clear</button>
    
    <div class="flyout-container">
      <button id="weightToggle">
        <canvas class="btn-indicator" id="weightIndicator" width="80" height="40"></canvas>
        <span class="btn-text">Line</span>
      </button>
      <div id="weightFlyout" class="flyout">
        <!-- Line weight buttons -->
      </div>
    </div>
    
    <div class="flyout-container">
      <button id="colorToggle">
        <div class="btn-indicator" id="colorIndicator"></div>
        <span class="btn-text">Color</span>
      </button>
      <div id="colorFlyout" class="flyout">
        <!-- Color buttons -->
      </div>
    </div>
    
    <div class="flyout-container">
      <button id="mirrorToggle">
        <canvas class="btn-indicator" id="mirrorIndicator" width="80" height="40"></canvas>
        <span class="btn-text">Mirror</span>
      </button>
      <div id="mirrorFlyout" class="flyout">
        <!-- Mirror buttons -->
      </div>
    </div>
    
    <button id="sewBtn">Sew</button>
  </div>
  
  <div class="status" id="status"></div>

  <script>
    // Fullscreen drawing app for Kindle
    const canvas = document.getElementById('pad');
    const ctx = canvas.getContext('2d');
    const menu = document.getElementById('menu');
    const statusDiv = document.getElementById('status');
    
    // Set canvas to full screen
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Drawing state
    let isDrawing = false;
    let strokes = [];
    let currentStroke = null;
    let lineWeight = 13;
    let color = '#000000';
    let mirrorMode = 'none';
    let currentShape = null; // null for line drawing, or shape name
    let counter = parseInt(localStorage.getItem('sewCounter') || '1');
    
    // Available options - 49 items (7x7 grid)
    // Rows 1-5: Line weights (35 weights)
    const weights = [
      1, 1, 2, 3, 5, 8, 13,              // Row 1: Fibonacci 1-13
      21, 34, 55, 65, 75, 85, 95,        // Row 2: Fibonacci 21, 34, then +10 increments
      105, 115, 125, 135, 145, 155, 165, // Row 3: +10 increments
      175, 185, 195, 205, 215, 225, 235, // Row 4: +10 increments
      245, 255, 265, 275, 285, 295, 300  // Row 5: +10 to 300
    ];
    
    // Rows 6-7: Shapes (14 shapes)
    const shapes = [
      {name: 'circle', label: '○'},
      {name: 'square', label: '□'},
      {name: 'triangle', label: '△'},
      {name: 'star', label: '★'},
      {name: 'heart', label: '♥'},
      {name: 'diamond', label: '◇'},
      {name: 'hexagon', label: '⬡'},
      {name: 'pentagon', label: '⬠'},
      {name: 'cross', label: '✚'},
      {name: 'x', label: '✕'},
      {name: 'arrowUp', label: '▲'},
      {name: 'arrowRight', label: '▶'},
      {name: 'spiral', label: '◎'},
      {name: 'wave', label: '〰'}
    ];
    
    const colors = ['#000000', '#333333', '#666666', '#999999', '#CCCCCC', '#FFFFFF'];
    const mirrors = [
      {mode: 'none', label: '○'},
      {mode: 'bilateral', label: '◐'},
      {mode: 'quad', label: '◰'},
      {mode: 'radial', label: '✱'}
    ];
    
    // Flyout visibility tracking
    let activeFlyout = null;
    
    function closeFlyouts() {
      document.querySelectorAll('.flyout').forEach(f => f.classList.remove('visible'));
      activeFlyout = null;
    }
    
    // Update visual indicators
    function updateWeightIndicator() {
      const canvas = document.getElementById('weightIndicator');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const thickness = Math.min(lineWeight, 20);
      ctx.fillStyle = '#000';
      ctx.fillRect(0, (canvas.height - thickness) / 2, canvas.width, thickness);
    }
    
    function updateColorIndicator() {
      const indicator = document.getElementById('colorIndicator');
      indicator.style.backgroundColor = color;
    }
    
    function updateMirrorIndicator() {
      const canvas = document.getElementById('mirrorIndicator');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      
      if (mirrorMode === 'bilateral') {
        // Vertical line
        ctx.beginPath();
        ctx.moveTo(cx, 0);
        ctx.lineTo(cx, canvas.height);
        ctx.stroke();
      } else if (mirrorMode === 'quad') {
        // Vertical and horizontal lines
        ctx.beginPath();
        ctx.moveTo(cx, 0);
        ctx.lineTo(cx, canvas.height);
        ctx.moveTo(0, cy);
        ctx.lineTo(canvas.width, cy);
        ctx.stroke();
      } else if (mirrorMode === 'radial') {
        // 8 lines radiating from center
        for (let angle = 0; angle < 360; angle += 45) {
          const rad = angle * Math.PI / 180;
          const x2 = cx + Math.cos(rad) * cx;
          const y2 = cy + Math.sin(rad) * cy;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
      }
      // 'none' shows no lines
    }
    
    // Initialize indicators
    updateWeightIndicator();
    updateColorIndicator();
    updateMirrorIndicator();
    
    // Create line weight buttons in flyout
    const weightFlyout = document.getElementById('weightFlyout');
    weights.forEach(w => {
      const btn = document.createElement('button');
      btn.className = 'weight-btn';
      if (w === 13) btn.classList.add('active');
      
      const icon = document.createElement('div');
      icon.className = 'weight-icon';
      
      const line = document.createElement('div');
      line.className = 'weight-line';
      line.style.height = Math.min(w, 40) + 'px';
      
      icon.appendChild(line);
      
      // Add label showing pixel size
      const label = document.createElement('div');
      label.className = 'weight-label';
      label.textContent = w + 'px';
      icon.appendChild(label);
      
      btn.appendChild(icon);
      
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        lineWeight = w;
        document.querySelectorAll('.weight-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        updateWeightIndicator();
        showStatus(`Line: ${w}px`);
        closeFlyouts();
        menu.classList.remove('visible');
      });
      
      weightFlyout.appendChild(btn);
    });
    
    // Create shape buttons in flyout (rows 6-7)
    shapes.forEach(shape => {
      const btn = document.createElement('button');
      btn.className = 'shape-btn';
      btn.textContent = shape.label;
      btn.style.fontSize = '24px';
      if (shape.name === 'circle' && currentShape === null) btn.classList.add('active');
      
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        currentShape = shape.name;
        document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        showStatus(`Shape: ${shape.name}`);
        closeFlyouts();
        menu.classList.remove('visible');
      });
      
      weightFlyout.appendChild(btn);
    });
    
    // Weight toggle button
    document.getElementById('weightToggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const flyout = document.getElementById('weightFlyout');
      if (activeFlyout === flyout) {
        closeFlyouts();
      } else {
        closeFlyouts();
        flyout.classList.add('visible');
        activeFlyout = flyout;
      }
    });
    
    // Create color buttons in flyout
    const colorFlyout = document.getElementById('colorFlyout');
    colors.forEach(c => {
      const btn = document.createElement('button');
      btn.className = 'color-btn';
      if (c === '#000000') btn.classList.add('active');
      
      const swatch = document.createElement('div');
      swatch.className = 'color-swatch';
      swatch.style.backgroundColor = c;
      
      btn.appendChild(swatch);
      
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        color = c;
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        updateColorIndicator();
        showStatus(`Color: ${c}`);
        closeFlyouts();
        menu.classList.remove('visible');
      });
      
      colorFlyout.appendChild(btn);
    });
    
    // Color toggle button
    document.getElementById('colorToggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const flyout = document.getElementById('colorFlyout');
      if (activeFlyout === flyout) {
        closeFlyouts();
      } else {
        closeFlyouts();
        flyout.classList.add('visible');
        activeFlyout = flyout;
      }
    });
    
    // Create mirror buttons in flyout
    const mirrorFlyout = document.getElementById('mirrorFlyout');
    mirrors.forEach(m => {
      const btn = document.createElement('button');
      btn.className = 'mirror-btn';
      btn.textContent = m.label;
      btn.style.fontSize = '20px';
      if (m.mode === 'none') btn.classList.add('active');
      
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        mirrorMode = m.mode;
        document.querySelectorAll('.mirror-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        updateMirrorIndicator();
        showStatus(`Mirror: ${m.mode}`);
        redraw();
        closeFlyouts();
        menu.classList.remove('visible');
      });
      
      mirrorFlyout.appendChild(btn);
    });
    
    // Mirror toggle button
    document.getElementById('mirrorToggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const flyout = document.getElementById('mirrorFlyout');
      if (activeFlyout === flyout) {
        closeFlyouts();
      } else {
        closeFlyouts();
        flyout.classList.add('visible');
        activeFlyout = flyout;
      }
    });
    
    // Menu toggle - tap bottom-left corner
    canvas.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      const x = touch.clientX;
      const y = touch.clientY;
      
      // Bottom-left corner (100x100px) toggles menu
      if (x < 100 && y > canvas.height - 100) {
        e.preventDefault();
        menu.classList.toggle('visible');
        return;
      }
      
      // If menu is open and tapping outside it, close menu
      if (menu.classList.contains('visible')) {
        menu.classList.remove('visible');
        return;
      }
      
      // Start drawing
      isDrawing = true;
      currentStroke = {
        points: [{x, y}],
        weight: lineWeight,
        color: color,
        shape: currentShape,
        startPoint: {x, y}
      };
    }, {passive: false});
    
    canvas.addEventListener('touchmove', (e) => {
      if (!isDrawing || menu.classList.contains('visible')) return;
      e.preventDefault();
      
      const touch = e.touches[0];
      const x = touch.clientX;
      const y = touch.clientY;
      
      currentStroke.points.push({x, y});
      drawStroke(currentStroke);
    }, {passive: false});
    
    canvas.addEventListener('touchend', (e) => {
      if (!isDrawing) return;
      e.preventDefault();
      isDrawing = false;
      
      // Shapes are already drawn during touchmove, just save the stroke
      strokes.push(currentStroke);
      currentStroke = null;
    });
    
    // Draw a single stroke
    function drawStroke(stroke) {
      // If shape mode, stamp shapes along the path
      if (stroke.shape && stroke.points.length > 0) {
        const segments = getMirroredSegments(stroke.points);
        
        // Stamp shapes along each mirrored segment
        segments.forEach(points => {
          points.forEach(pt => {
            drawShape(stroke.shape, pt.x, pt.y, stroke.weight, stroke.color);
          });
        });
      } else if (!stroke.shape) {
        // Normal line drawing
        const segments = getMirroredSegments(stroke.points);
        
        ctx.strokeStyle = stroke.color;
        ctx.lineWidth = stroke.weight;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Draw each segment separately
        segments.forEach(points => {
          ctx.beginPath();
          points.forEach((pt, i) => {
            if (i === 0) ctx.moveTo(pt.x, pt.y);
            else ctx.lineTo(pt.x, pt.y);
          });
          ctx.stroke();
        });
      }
    }
    
    // Get mirrored segments based on mode
    function getMirroredSegments(points) {
      if (mirrorMode === 'none') return [points];
      
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const segments = [points]; // Original stroke
      
      if (mirrorMode === 'bilateral') {
        // Mirror across vertical center
        segments.push(points.map(p => ({x: 2*cx - p.x, y: p.y})));
      } else if (mirrorMode === 'quad') {
        // Mirror across vertical, horizontal, and both
        segments.push(points.map(p => ({x: 2*cx - p.x, y: p.y})));
        segments.push(points.map(p => ({x: p.x, y: 2*cy - p.y})));
        segments.push(points.map(p => ({x: 2*cx - p.x, y: 2*cy - p.y})));
      } else if (mirrorMode === 'radial') {
        // Rotate around center at 45-degree intervals
        for (let angle = 45; angle < 360; angle += 45) {
          const rad = angle * Math.PI / 180;
          const cos_a = Math.cos(rad);
          const sin_a = Math.sin(rad);
          segments.push(points.map(p => {
            const dx = p.x - cx;
            const dy = p.y - cy;
            return {
              x: cx + dx * cos_a - dy * sin_a,
              y: cy + dx * sin_a + dy * cos_a
            };
          }));
        }
      }
      
      return segments;
    }
    
    // Draw complete shape at point
    function drawShape(shapeName, x, y, weight, color) {
      const size = weight * 2;
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = weight / 2;
      
      ctx.beginPath();
      switch(shapeName) {
        case 'circle':
          ctx.arc(x, y, size, 0, Math.PI * 2);
          break;
        case 'square':
          ctx.rect(x - size, y - size, size * 2, size * 2);
          break;
        case 'triangle':
          ctx.moveTo(x, y - size);
          ctx.lineTo(x + size, y + size);
          ctx.lineTo(x - size, y + size);
          ctx.closePath();
          break;
        case 'star':
          drawStar(x, y, 5, size, size / 2);
          break;
        case 'heart':
          drawHeart(x, y, size);
          break;
        case 'diamond':
          ctx.moveTo(x, y - size);
          ctx.lineTo(x + size, y);
          ctx.lineTo(x, y + size);
          ctx.lineTo(x - size, y);
          ctx.closePath();
          break;
        case 'hexagon':
          drawPolygon(x, y, 6, size);
          break;
        case 'pentagon':
          drawPolygon(x, y, 5, size);
          break;
        case 'cross':
          const w = size / 3;
          ctx.rect(x - w, y - size, w * 2, size * 2);
          ctx.rect(x - size, y - w, size * 2, w * 2);
          break;
        case 'x':
          ctx.moveTo(x - size, y - size);
          ctx.lineTo(x + size, y + size);
          ctx.moveTo(x + size, y - size);
          ctx.lineTo(x - size, y + size);
          break;
        case 'arrowUp':
          ctx.moveTo(x, y - size);
          ctx.lineTo(x + size, y + size / 2);
          ctx.lineTo(x, y);
          ctx.lineTo(x - size, y + size / 2);
          ctx.closePath();
          break;
        case 'arrowRight':
          ctx.moveTo(x + size, y);
          ctx.lineTo(x - size / 2, y + size);
          ctx.lineTo(x, y);
          ctx.lineTo(x - size / 2, y - size);
          ctx.closePath();
          break;
        case 'spiral':
          drawSpiral(x, y, size);
          break;
        case 'wave':
          drawWave(x, y, size);
          break;
      }
      ctx.stroke();
    }
    
    // Helper functions for complex shapes
    function drawStar(x, y, points, outer, inner) {
      ctx.moveTo(x, y - outer);
      for (let i = 0; i < points * 2; i++) {
        const radius = i % 2 === 0 ? outer : inner;
        const angle = (Math.PI * i) / points - Math.PI / 2;
        ctx.lineTo(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
      }
      ctx.closePath();
    }
    
    function drawHeart(x, y, size) {
      ctx.moveTo(x, y + size / 4);
      ctx.bezierCurveTo(x, y - size / 4, x - size, y - size / 4, x - size, y + size / 4);
      ctx.bezierCurveTo(x - size, y + size, x, y + size, x, y + size * 1.5);
      ctx.bezierCurveTo(x, y + size, x + size, y + size, x + size, y + size / 4);
      ctx.bezierCurveTo(x + size, y - size / 4, x, y - size / 4, x, y + size / 4);
    }
    
    function drawPolygon(x, y, sides, size) {
      ctx.moveTo(x + size * Math.cos(0), y + size * Math.sin(0));
      for (let i = 1; i <= sides; i++) {
        ctx.lineTo(x + size * Math.cos(i * 2 * Math.PI / sides), y + size * Math.sin(i * 2 * Math.PI / sides));
      }
      ctx.closePath();
    }
    
    function drawSpiral(x, y, size) {
      let angle = 0;
      let radius = 0;
      ctx.moveTo(x, y);
      while (radius < size) {
        angle += 0.1;
        radius += 0.05 * size;
        ctx.lineTo(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
      }
    }
    
    function drawWave(x, y, size) {
      ctx.moveTo(x - size, y);
      for (let i = 0; i <= 20; i++) {
        const xPos = x - size + (i / 20) * size * 2;
        const yPos = y + Math.sin(i / 3) * size / 2;
        ctx.lineTo(xPos, yPos);
      }
    }
    
    // Get mirrored points (for saving) based on mode
    function getMirroredPoints(points) {
      const segments = getMirroredSegments(points);
      // Flatten all segments into one array for export
      return segments.flat();
    }
    
    // Redraw everything
    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      strokes.forEach(stroke => {
        drawStroke(stroke);
      });
      if (currentStroke) drawStroke(currentStroke);
    }
    
    // Clear canvas
    document.getElementById('clearBtn').addEventListener('click', () => {
      strokes = [];
      currentStroke = null;
      redraw();
      showStatus('Cleared');
      closeFlyouts();
      menu.classList.remove('visible');
    });
    
    // Save drawing
    document.getElementById('sewBtn').addEventListener('click', () => {
      const now = new Date();
      const months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
      const dateStr = `${months[now.getMonth()]} ${now.getDate()}, ${now.getFullYear()}-${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
      const filename = `${dateStr}#${pad(counter, 4)}.txt`;
      
      // Expand strokes with mirrors
      const expandedStrokes = strokes.map(stroke => ({
        color: stroke.color,
        lineWidth: stroke.weight,
        points: getMirroredPoints(stroke.points)
      }));
      
      const data = {
        canvasWidth: canvas.width,
        canvasHeight: canvas.height,
        strokes: expandedStrokes
      };
      
      // Download
      const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      
      counter++;
      localStorage.setItem('sewCounter', counter.toString());
      
      showStatus(`Saved: ${filename}`, 3000);
      closeFlyouts();
      menu.classList.remove('visible');
    });
    
    function pad(num, size = 2) {
      return num.toString().padStart(size, '0');
    }
    
    function showStatus(msg, duration = 2000) {
      statusDiv.textContent = msg;
      statusDiv.classList.add('show');
      setTimeout(() => statusDiv.classList.remove('show'), duration);
    }
    
    // Show initial help
    setTimeout(() => {
      showStatus('Tap bottom-left corner for menu', 3000);
    }, 500);
    
    // Prevent scrolling/zooming
    document.addEventListener('touchmove', (e) => {
      if (e.touches.length > 1) e.preventDefault();
    }, {passive: false});
    
    // Request fullscreen on load (if supported)
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen().catch(() => {});
    } else if (document.documentElement.webkitRequestFullscreen) {
      document.documentElement.webkitRequestFullscreen().catch(() => {});
    }
    
    // Force scroll to hide URL bar on Kindle/mobile browsers
    window.addEventListener('load', () => {
      setTimeout(() => {
        window.scrollTo(0, 1);
      }, 100);
    });
    
    // Hide address bar on orientation change
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        window.scrollTo(0, 1);
      }, 100);
    });
  </script>
</body>
</html>
