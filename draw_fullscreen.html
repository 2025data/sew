<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Sew Fullscreen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#ffffff">
  <style>
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #fff;
      position: fixed;
    }
    #pad {
      display: block;
      width: 100vw;
      height: 100vh;
      touch-action: none;
      background: #fff;
      cursor: crosshair;
    }
    /* Hidden UI - shown only when tapping corner */
    #menu {
      position: fixed;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      border: 2px solid #000;
      padding: 8px;
      display: none;
      font-family: sans-serif;
      font-size: 14px;
      z-index: 1000;
    }
    #menu.visible {
      display: flex;
      flex-direction: row;
      gap: 8px;
      justify-content: space-around;
      align-items: center;
    }
    #menu button {
      font-size: 14px;
      padding: 10px 16px;
      border: 2px solid #000;
      background: #fff;
      cursor: pointer;
      white-space: nowrap;
      position: relative;
      overflow: hidden;
    }
    #menu button:active, #menu button.active {
      background: #ddd;
      border-color: #333;
    }
    
    /* Visual indicators on toggle buttons */
    .btn-indicator {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 1;
    }
    .btn-text {
      position: relative;
      z-index: 2;
      background: #fff;
      padding: 0 4px;
      display: inline-block;
    }
    #weightToggle .btn-text,
    #colorToggle .btn-text,
    #mirrorToggle .btn-text {
      background: rgba(255, 255, 255, 0.9);
      padding: 2px 6px;
      border-radius: 2px;
    }
    
    /* Flyout containers */
    .flyout-container {
      position: relative;
      display: inline-block;
    }
    .flyout {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-bottom: 8px;
      background: rgba(255,255,255,0.98);
      border: 2px solid #000;
      padding: 8px;
      display: none;
      flex-wrap: wrap;
      gap: 6px;
      max-width: 300px;
      justify-content: center;
    }
    .flyout.visible {
      display: flex;
    }
    
    /* Full-screen grid for line weights */
    #weightFlyout {
      position: fixed;
      top: 10px;
      left: 10px;
      right: 10px;
      bottom: 80px;
      max-width: 100%;
      transform: none;
      margin: 0;
      display: none;
      grid-template-columns: repeat(7, 1fr);
      grid-template-rows: repeat(7, 1fr);
      overflow-y: auto;
    }
    #weightFlyout.visible {
      display: grid;
    }
    
    .flyout button {
      min-width: 40px;
      padding: 0;
      font-size: 11px;
      overflow: visible;
      border: 1px solid #ccc;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .weight-icon {
      width: 100%;
      height: 100%;
      min-height: 50px;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      position: relative;
      overflow: visible;
    }
    .weight-line {
      background: #000;
      width: 100%;
      max-height: 50px;
    }
    .weight-label {
      position: absolute;
      top: 2px;
      left: 2px;
      background: rgba(255, 255, 255, 0.9);
      padding: 1px 3px;
      font-size: 9px;
      border-radius: 2px;
      z-index: 10;
      pointer-events: none;
      color: #000;
    }
    .color-swatch {
      width: 40px;
      height: 30px;
      border: 1px solid #000;
    }
    .status {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 4px 8px;
      font-size: 12px;
      font-family: monospace;
      border-radius: 4px;
      display: none;
      z-index: 999;
    }
    .status.show {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="pad"></canvas>
  
  <div id="menu">
    <button id="clearBtn">Clear</button>
    
    <div class="flyout-container">
      <button id="weightToggle">
        <canvas class="btn-indicator" id="weightIndicator" width="80" height="40"></canvas>
        <span class="btn-text">Line</span>
      </button>
      <div id="weightFlyout" class="flyout">
        <!-- Line weight buttons -->
      </div>
    </div>
    
    <div class="flyout-container">
      <button id="colorToggle">
        <div class="btn-indicator" id="colorIndicator"></div>
        <span class="btn-text">Color</span>
      </button>
      <div id="colorFlyout" class="flyout">
        <!-- Color buttons -->
      </div>
    </div>
    
    <div class="flyout-container">
      <button id="mirrorToggle">
        <canvas class="btn-indicator" id="mirrorIndicator" width="80" height="40"></canvas>
        <span class="btn-text">Mirror</span>
      </button>
      <div id="mirrorFlyout" class="flyout">
        <!-- Mirror buttons -->
      </div>
    </div>
    
    <button id="sewBtn">Sew</button>
  </div>
  
  <div class="status" id="status"></div>

  <script>
    // Fullscreen drawing app for Kindle
    const canvas = document.getElementById('pad');
    const ctx = canvas.getContext('2d');
    const menu = document.getElementById('menu');
    const statusDiv = document.getElementById('status');
    
    // Set canvas to full screen
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Drawing state
    let isDrawing = false;
    let strokes = [];
    let currentStroke = null;
    let lineWeight = 13;
    let color = '#000000';
    let mirrorMode = 'none';
    let currentShape = null; // null for line drawing, or shape name
    let lineCap = 'round'; // 'round' or 'butt' (square)
    let counter = parseInt(localStorage.getItem('sewCounter') || '1');
    
    // Available options - 49 items (7x7 grid)
    // Rows 1-3: Line weights (19 weights + 2 line mode buttons)
    const weights = [
      1, 3,                              // 2 weights < 5px
      5, 6, 7, 8, 9, 10, 11, 12, 13,    // Row 1 continued + Row 2 start: dense around 13
      14, 15, 16, 17, 18, 20, 22,       // Row 2 continued: dense around 13
      25, 30, 40, 55, 75, 100,          // Row 3: spreading out
      150, 200,                          // 2 weights > 100px
      'round', 'square'                  // Line mode reset buttons
    ];
    
    // Rows 4-8: Shapes (33 shapes for 7 columns Ã— 5 rows - 2 = 33)
    const shapes = [
      // Row 4: Celtic knot elements
      {name: 'curve', label: 'âŒ’'},
      {name: 'scurve', label: 'âˆ½'},
      {name: 'loop', label: 'âˆž'},
      {name: 'arc', label: 'âŒ“'},
      {name: 'crescent', label: 'â˜½'},
      {name: 'triquetra', label: 'â—¬'},
      {name: 'knot', label: 'âš¯'},
      // Row 5: Texture elements
      {name: 'dot', label: 'â€¢'},
      {name: 'ring', label: 'â—¦'},
      {name: 'doublering', label: 'â—‰'},
      {name: 'quatrefoil', label: 'â€'},
      {name: 'leaf', label: 'ðŸƒ'},
      {name: 'teardrop', label: 'ðŸ’§'},
      {name: 'star', label: 'â˜…'},
      // Row 6: Basic shapes
      {name: 'ellipse', label: 'â¬­'},
      {name: 'maze', label: 'â—Ž'},
      {name: 'hexagon', label: 'â¬¡'},
      {name: 'doublej', label: 'âŸ†'},
      {name: 'heart', label: 'â™¥'},
      {name: 'cross', label: 'âœš'},
      {name: 'x', label: 'âœ•'},
      // Row 7: Arrows & patterns
      {name: 'smiley', label: 'â˜º'},
      {name: 'arrowRight', label: 'â–¶'},
      {name: 'spiral', label: 'â—Ž'},
      {name: 'wave', label: 'ã€°'},
      {name: 'zigzag', label: 'â©˜'},
      {name: 'chevron', label: 'âŒƒ'},
      {name: 'brackets', label: 'ã€ˆã€‰'},
      // Row 8: Grid patterns
      {name: 'grid', label: 'âŠž'},
      {name: 'isogrid', label: 'â—Š'},
      {name: 'hatch', label: 'â«½'},
      {name: 'crosshatch', label: 'âŠ '},
      {name: 'hexgrid', label: 'â¬¡'},
      {name: 'brickgrid', label: 'â–­'},
      {name: 'infinity', label: 'âˆž'}
    ];
    
    const colors = ['#000000', '#333333', '#666666', '#999999', '#CCCCCC', '#FFFFFF'];
    const mirrors = [
      {mode: 'none', label: 'â—‹'},
      {mode: 'bilateral', label: 'â—'},
      {mode: 'quad', label: 'â—°'},
      {mode: 'radial', label: 'âœ±'}
    ];
    
    // Flyout visibility tracking
    let activeFlyout = null;
    
    function closeFlyouts() {
      document.querySelectorAll('.flyout').forEach(f => f.classList.remove('visible'));
      activeFlyout = null;
    }
    
    // Update visual indicators
    function updateWeightIndicator() {
      const canvas = document.getElementById('weightIndicator');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const thickness = Math.min(lineWeight, 20);
      ctx.fillStyle = '#000';
      ctx.fillRect(0, (canvas.height - thickness) / 2, canvas.width, thickness);
    }
    
    function updateColorIndicator() {
      const indicator = document.getElementById('colorIndicator');
      indicator.style.backgroundColor = color;
    }
    
    function updateMirrorIndicator() {
      const canvas = document.getElementById('mirrorIndicator');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      
      if (mirrorMode === 'bilateral') {
        // Vertical line
        ctx.beginPath();
        ctx.moveTo(cx, 0);
        ctx.lineTo(cx, canvas.height);
        ctx.stroke();
      } else if (mirrorMode === 'quad') {
        // Vertical and horizontal lines
        ctx.beginPath();
        ctx.moveTo(cx, 0);
        ctx.lineTo(cx, canvas.height);
        ctx.moveTo(0, cy);
        ctx.lineTo(canvas.width, cy);
        ctx.stroke();
      } else if (mirrorMode === 'radial') {
        // 8 lines radiating from center
        for (let angle = 0; angle < 360; angle += 45) {
          const rad = angle * Math.PI / 180;
          const x2 = cx + Math.cos(rad) * cx;
          const y2 = cy + Math.sin(rad) * cy;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
      }
      // 'none' shows no lines
    }
    
    // Initialize indicators
    updateWeightIndicator();
    updateColorIndicator();
    updateMirrorIndicator();
    
    // Create line weight buttons in flyout
    const weightFlyout = document.getElementById('weightFlyout');
    weights.forEach(w => {
      const btn = document.createElement('button');
      
      // Handle special line mode reset buttons
      if (w === 'round' || w === 'square') {
        btn.className = 'weight-btn';
        btn.style.fontSize = '24px';
        btn.textContent = w === 'round' ? 'â—' : 'â– ';
        
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          currentShape = null; // Reset to line drawing mode
          lineCap = w === 'round' ? 'round' : 'butt';
          document.querySelectorAll('.weight-btn').forEach(b => b.classList.remove('active'));
          document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          showStatus(`Line mode: ${w} cap`);
          closeFlyouts();
          menu.classList.remove('visible');
        });
        
        weightFlyout.appendChild(btn);
        return;
      }
      
      // Normal weight buttons
      btn.className = 'weight-btn';
      if (w === 13) btn.classList.add('active');
      
      const icon = document.createElement('div');
      icon.className = 'weight-icon';
      
      const line = document.createElement('div');
      line.className = 'weight-line';
      // Show actual size up to button size (50px)
      line.style.height = Math.min(w, 50) + 'px';
      
      icon.appendChild(line);
      
      // Add label showing pixel size in bottom-right corner
      const label = document.createElement('div');
      label.className = 'weight-label';
      label.textContent = w + 'px';
      icon.appendChild(label);
      
      btn.appendChild(icon);
      
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        lineWeight = w;
        document.querySelectorAll('.weight-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        updateWeightIndicator();
        showStatus(`Line: ${w}px`);
        closeFlyouts();
        menu.classList.remove('visible');
      });
      
      weightFlyout.appendChild(btn);
    });
    
    // Create shape buttons in flyout (rows 6-7)
    shapes.forEach(shape => {
      const btn = document.createElement('button');
      btn.className = 'shape-btn';
      btn.textContent = shape.label;
      btn.style.fontSize = '24px';
      if (shape.name === 'circle' && currentShape === null) btn.classList.add('active');
      
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        currentShape = shape.name;
        document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        showStatus(`Shape: ${shape.name}`);
        closeFlyouts();
        menu.classList.remove('visible');
      });
      
      weightFlyout.appendChild(btn);
    });
    
    // Weight toggle button
    document.getElementById('weightToggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const flyout = document.getElementById('weightFlyout');
      if (activeFlyout === flyout) {
        closeFlyouts();
      } else {
        closeFlyouts();
        flyout.classList.add('visible');
        activeFlyout = flyout;
      }
    });
    
    // Create color buttons in flyout
    const colorFlyout = document.getElementById('colorFlyout');
    colors.forEach(c => {
      const btn = document.createElement('button');
      btn.className = 'color-btn';
      if (c === '#000000') btn.classList.add('active');
      
      const swatch = document.createElement('div');
      swatch.className = 'color-swatch';
      swatch.style.backgroundColor = c;
      
      btn.appendChild(swatch);
      
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        color = c;
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        updateColorIndicator();
        showStatus(`Color: ${c}`);
        closeFlyouts();
        menu.classList.remove('visible');
      });
      
      colorFlyout.appendChild(btn);
    });
    
    // Color toggle button
    document.getElementById('colorToggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const flyout = document.getElementById('colorFlyout');
      if (activeFlyout === flyout) {
        closeFlyouts();
      } else {
        closeFlyouts();
        flyout.classList.add('visible');
        activeFlyout = flyout;
      }
    });
    
    // Create mirror buttons in flyout
    const mirrorFlyout = document.getElementById('mirrorFlyout');
    mirrors.forEach(m => {
      const btn = document.createElement('button');
      btn.className = 'mirror-btn';
      btn.textContent = m.label;
      btn.style.fontSize = '20px';
      if (m.mode === 'none') btn.classList.add('active');
      
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        mirrorMode = m.mode;
        document.querySelectorAll('.mirror-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        updateMirrorIndicator();
        showStatus(`Mirror: ${m.mode}`);
        redraw();
        closeFlyouts();
        menu.classList.remove('visible');
      });
      
      mirrorFlyout.appendChild(btn);
    });
    
    // Mirror toggle button
    document.getElementById('mirrorToggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const flyout = document.getElementById('mirrorFlyout');
      if (activeFlyout === flyout) {
        closeFlyouts();
      } else {
        closeFlyouts();
        flyout.classList.add('visible');
        activeFlyout = flyout;
      }
    });
    
    // Menu toggle - tap bottom-left corner
    let isRotatingShape = false;
    let shapeRotation = 0;
    let rotationStartAngle = 0;
    let shapeAnchorPoint = null;
    let holdTimer = null;
    let rotationModeActive = false;
    const HOLD_DURATION = 500; // milliseconds to hold before rotation activates
    
    canvas.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      const x = touch.clientX;
      const y = touch.clientY;
      
      // Bottom-left corner (100x100px) toggles menu
      if (x < 100 && y > canvas.height - 100) {
        e.preventDefault();
        menu.classList.toggle('visible');
        return;
      }
      
      // Bottom-right corner (25x25px) = undo last stroke
      if (x > canvas.width - 25 && y > canvas.height - 25) {
        e.preventDefault();
        if (strokes.length > 0) {
          strokes.pop();
          redraw();
          showStatus('Undo', 1000);
        } else {
          showStatus('Nothing to undo', 1000);
        }
        return;
      }
      
      // If menu is open and tapping outside it, close menu
      if (menu.classList.contains('visible')) {
        menu.classList.remove('visible');
        return;
      }
      
      // Start drawing
      isDrawing = true;
      currentStroke = {
        points: [{x, y}],
        weight: lineWeight,
        color: color,
        shape: currentShape,
        lineCap: lineCap,
        rotation: 0,
        startPoint: {x, y}
      };

      // If in shape mode, immediately stamp the shape at tap location
      if (currentShape) {
        shapeAnchorPoint = {x, y};
        shapeRotation = 0;
        rotationModeActive = false;
        drawStroke(currentStroke);
        
        // Start hold timer for rotation mode
        holdTimer = setTimeout(() => {
          rotationModeActive = true;
          showStatus('Rotation active - drag to rotate', 1500);
        }, HOLD_DURATION);
      }
    }, {passive: false});
    
    canvas.addEventListener('touchmove', (e) => {
      if (!isDrawing || menu.classList.contains('visible')) return;
      e.preventDefault();
      
      // Shape rotation mode: hold activated, now drag to rotate
      if (currentShape && rotationModeActive) {
        const touch = e.touches[0];
        const dx = touch.clientX - shapeAnchorPoint.x;
        const dy = touch.clientY - shapeAnchorPoint.y;
        
        // Calculate angle from anchor point to current touch position
        // atan2 returns angle in radians: right=0, down=Ï€/2, left=Ï€, up=-Ï€/2
        const angle = Math.atan2(dy, dx);
        
        // Convert to rotation (0Â° = right/east, rotating clockwise)
        shapeRotation = angle;
        currentStroke.rotation = shapeRotation;
        
        // Redraw with new rotation
        redraw();
        drawStroke(currentStroke);
        return;
      }
      
      // If shape mode but rotation not active yet, cancel hold timer on any movement
      if (currentShape && !rotationModeActive && holdTimer) {
        clearTimeout(holdTimer);
        holdTimer = null;
        return;
      }
      
      // Normal line drawing mode - add points and draw
      if (!currentShape) {
        const touch = e.touches[0];
        const x = touch.clientX;
        const y = touch.clientY;
        
        currentStroke.points.push({x, y});
        drawStroke(currentStroke);
      }
    }, {passive: false});
    
    canvas.addEventListener('touchend', (e) => {
      if (!isDrawing) return;
      e.preventDefault();
      
      // Clear hold timer if still active
      if (holdTimer) {
        clearTimeout(holdTimer);
        holdTimer = null;
      }
      
      // Reset rotation tracking
      isRotatingShape = false;
      rotationModeActive = false;
      rotationStartAngle = 0;
      shapeAnchorPoint = null;
      
      isDrawing = false;
      
      // Save the stroke (shape or line)
      strokes.push(currentStroke);
      currentStroke = null;
    });
    
    // Draw a single stroke
    function drawStroke(stroke) {
      // If shape mode, stamp shape once at the first point with rotation
      if (stroke.shape && stroke.points.length > 0) {
        const pt = stroke.points[0]; // Only use first point
        const segments = getMirroredSegments([pt]);
        const rotation = stroke.rotation || 0;
        
        // Stamp shape at each mirrored position
        segments.forEach(points => {
          points.forEach(mirroredPt => {
            drawShape(stroke.shape, mirroredPt.x, mirroredPt.y, stroke.weight, stroke.color, rotation);
          });
        });
      } else if (!stroke.shape) {
        // Normal line drawing
        const segments = getMirroredSegments(stroke.points);
        
        ctx.strokeStyle = stroke.color;
        ctx.lineWidth = stroke.weight;
        ctx.lineCap = stroke.lineCap || 'round';
        ctx.lineJoin = 'round';
        
        // Draw each segment separately
        segments.forEach(points => {
          ctx.beginPath();
          points.forEach((pt, i) => {
            if (i === 0) ctx.moveTo(pt.x, pt.y);
            else ctx.lineTo(pt.x, pt.y);
          });
          ctx.stroke();
        });
      }
    }
    
    // Get mirrored segments based on mode
    function getMirroredSegments(points) {
      if (mirrorMode === 'none') return [points];
      
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const segments = [points]; // Original stroke
      
      if (mirrorMode === 'bilateral') {
        // Mirror across vertical center
        segments.push(points.map(p => ({x: 2*cx - p.x, y: p.y})));
      } else if (mirrorMode === 'quad') {
        // Mirror across vertical, horizontal, and both
        segments.push(points.map(p => ({x: 2*cx - p.x, y: p.y})));
        segments.push(points.map(p => ({x: p.x, y: 2*cy - p.y})));
        segments.push(points.map(p => ({x: 2*cx - p.x, y: 2*cy - p.y})));
      } else if (mirrorMode === 'radial') {
        // Rotate around center at 45-degree intervals
        for (let angle = 45; angle < 360; angle += 45) {
          const rad = angle * Math.PI / 180;
          const cos_a = Math.cos(rad);
          const sin_a = Math.sin(rad);
          segments.push(points.map(p => {
            const dx = p.x - cx;
            const dy = p.y - cy;
            return {
              x: cx + dx * cos_a - dy * sin_a,
              y: cy + dx * sin_a + dy * cos_a
            };
          }));
        }
      }
      
      return segments;
    }
    
    // Draw complete shape at point
    function drawShape(shapeName, x, y, weight, color, rotation = 0) {
      const size = weight * 2;
      ctx.save(); // Save current context state
      
      // Apply rotation if specified
      if (rotation !== 0) {
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.translate(-x, -y);
      }
      
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = weight / 2;
      
      ctx.beginPath();
      switch(shapeName) {
        case 'circle':
          ctx.arc(x, y, size, 0, Math.PI * 2);
          break;
        case 'square':
          ctx.rect(x - size, y - size, size * 2, size * 2);
          break;
        case 'ellipse':
          ctx.ellipse(x, y, size * 1.5, size, 0, 0, Math.PI * 2);
          break;
        case 'maze':
          drawMaze(x, y, size);
          break;
        case 'doublej':
          drawDoubleJ(x, y, size);
          break;
        case 'smiley':
          drawSmiley(x, y, size);
          break;
        case 'star':
          drawStar(x, y, 5, size, size / 2);
          break;
        case 'heart':
          drawHeart(x, y, size);
          break;
        case 'hexagon':
          drawPolygon(x, y, 6, size);
          break;
        case 'cross':
          const w = size / 3;
          ctx.rect(x - w, y - size, w * 2, size * 2);
          ctx.rect(x - size, y - w, size * 2, w * 2);
          break;
        case 'x':
          ctx.moveTo(x - size, y - size);
          ctx.lineTo(x + size, y + size);
          ctx.moveTo(x + size, y - size);
          ctx.lineTo(x - size, y + size);
          break;
        case 'arrowRight':
          ctx.moveTo(x + size, y);
          ctx.lineTo(x - size / 2, y + size);
          ctx.lineTo(x, y);
          ctx.lineTo(x - size / 2, y - size);
          ctx.closePath();
          break;
        case 'spiral':
          drawSpiral(x, y, size);
          break;
        case 'wave':
          drawWave(x, y, size);
          break;
        case 'zigzag':
          drawZigzag(x, y, size);
          break;
        case 'chevron':
          drawChevron(x, y, size);
          break;
        case 'brackets':
          drawBrackets(x, y, size);
          break;
        case 'grid':
          drawGrid(x, y, size);
          break;
        case 'isogrid':
          drawIsogrid(x, y, size);
          break;
        case 'hatch':
          drawHatch(x, y, size);
          break;
        case 'crosshatch':
          drawCrosshatch(x, y, size);
          break;
        case 'hexgrid':
          drawHexgrid(x, y, size);
          break;
        case 'brickgrid':
          drawBrickgrid(x, y, size);
          break;
        case 'infinity':
          drawInfinity(x, y, size);
          break;
        case 'curve':
          drawCurve(x, y, size);
          break;
        case 'scurve':
          drawSCurve(x, y, size);
          break;
        case 'loop':
          drawLoop(x, y, size);
          break;
        case 'arc':
          drawArc(x, y, size);
          break;
        case 'crescent':
          drawCrescent(x, y, size);
          break;
        case 'triquetra':
          drawTriquetra(x, y, size);
          break;
        case 'knot':
          drawKnot(x, y, size);
          break;
        case 'dot':
          ctx.arc(x, y, size / 2, 0, Math.PI * 2);
          ctx.fill();
          break;
        case 'ring':
          ctx.arc(x, y, size, 0, Math.PI * 2);
          break;
        case 'doublering':
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.moveTo(x + size / 2, y);
          ctx.arc(x, y, size / 2, 0, Math.PI * 2);
          break;
        case 'quatrefoil':
          drawQuatrefoil(x, y, size);
          break;
        case 'leaf':
          drawLeaf(x, y, size);
          break;
        case 'teardrop':
          drawTeardrop(x, y, size);
          break;
      }
      ctx.stroke();
      ctx.restore(); // Restore context state (removes rotation)
    }
    
    // Helper functions for complex shapes
    function drawStar(x, y, points, outer, inner) {
      ctx.moveTo(x, y - outer);
      for (let i = 0; i < points * 2; i++) {
        const radius = i % 2 === 0 ? outer : inner;
        const angle = (Math.PI * i) / points - Math.PI / 2;
        ctx.lineTo(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
      }
      ctx.closePath();
    }
    
    function drawHeart(x, y, size) {
      ctx.moveTo(x, y + size / 4);
      ctx.bezierCurveTo(x, y - size / 4, x - size, y - size / 4, x - size, y + size / 4);
      ctx.bezierCurveTo(x - size, y + size, x, y + size, x, y + size * 1.5);
      ctx.bezierCurveTo(x, y + size, x + size, y + size, x + size, y + size / 4);
      ctx.bezierCurveTo(x + size, y - size / 4, x, y - size / 4, x, y + size / 4);
    }
    
    function drawPolygon(x, y, sides, size) {
      ctx.moveTo(x + size * Math.cos(0), y + size * Math.sin(0));
      for (let i = 1; i <= sides; i++) {
        ctx.lineTo(x + size * Math.cos(i * 2 * Math.PI / sides), y + size * Math.sin(i * 2 * Math.PI / sides));
      }
      ctx.closePath();
    }
    
    function drawSpiral(x, y, size) {
      let angle = 0;
      let radius = 0;
      ctx.moveTo(x, y);
      while (radius < size) {
        angle += 0.1;
        radius += 0.05 * size;
        ctx.lineTo(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
      }
    }
    
    function drawWave(x, y, size) {
      ctx.moveTo(x - size, y);
      for (let i = 0; i <= 20; i++) {
        const xPos = x - size + (i / 20) * size * 2;
        const yPos = y + Math.sin(i / 3) * size / 2;
        ctx.lineTo(xPos, yPos);
      }
    }

    function drawMaze(x, y, size) {
      // Circular maze pattern
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.moveTo(x + size * 0.66, y);
      ctx.arc(x, y, size * 0.66, 0, Math.PI * 2);
      ctx.moveTo(x + size * 0.33, y);
      ctx.arc(x, y, size * 0.33, 0, Math.PI * 2);
      // Radial lines
      for (let i = 0; i < 4; i++) {
        const angle = (i * Math.PI) / 2;
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * size, y + Math.sin(angle) * size);
      }
    }

    function drawDoubleJ(x, y, size) {
      // First J
      ctx.moveTo(x - size / 2, y - size);
      ctx.lineTo(x - size / 2, y + size / 2);
      ctx.quadraticCurveTo(x - size / 2, y + size, x - size, y + size);
      // Second J (mirrored)
      ctx.moveTo(x + size / 2, y - size);
      ctx.lineTo(x + size / 2, y + size / 2);
      ctx.quadraticCurveTo(x + size / 2, y + size, x + size, y + size);
    }

    function drawSmiley(x, y, size) {
      // Face circle
      ctx.arc(x, y, size, 0, Math.PI * 2);
      // Eyes
      ctx.moveTo(x - size / 3, y - size / 3);
      ctx.arc(x - size / 3, y - size / 3, size / 8, 0, Math.PI * 2);
      ctx.moveTo(x + size / 3, y - size / 3);
      ctx.arc(x + size / 3, y - size / 3, size / 8, 0, Math.PI * 2);
      // Smile
      ctx.moveTo(x - size / 2, y + size / 4);
      ctx.quadraticCurveTo(x, y + size / 2, x + size / 2, y + size / 4);
    }

    function drawCurve(x, y, size) {
      ctx.moveTo(x - size, y);
      ctx.quadraticCurveTo(x - size, y - size, x, y - size);
    }

    function drawSCurve(x, y, size) {
      ctx.moveTo(x - size, y - size / 2);
      ctx.bezierCurveTo(x - size / 2, y - size, x + size / 2, y, x + size, y + size / 2);
    }

    function drawLoop(x, y, size) {
      ctx.moveTo(x - size, y);
      ctx.bezierCurveTo(x - size, y - size, x + size, y - size, x + size, y);
      ctx.bezierCurveTo(x + size, y + size, x - size, y + size, x - size, y);
    }

    function drawArc(x, y, size) {
      ctx.arc(x, y, size, 0, Math.PI);
    }

    function drawCrescent(x, y, size) {
      ctx.arc(x, y, size, 0.2 * Math.PI, 1.8 * Math.PI);
      ctx.arc(x + size / 3, y, size * 0.7, 1.8 * Math.PI, 0.2 * Math.PI, true);
    }

    function drawTriquetra(x, y, size) {
      for (let i = 0; i < 3; i++) {
        const angle = (i * 2 * Math.PI) / 3 - Math.PI / 2;
        const cx = x + Math.cos(angle) * size / 2;
        const cy = y + Math.sin(angle) * size / 2;
        ctx.moveTo(cx + size * 0.7, cy);
        ctx.arc(cx, cy, size * 0.7, 0, Math.PI * 2);
      }
    }

    function drawKnot(x, y, size) {
      ctx.moveTo(x - size, y - size);
      ctx.bezierCurveTo(x - size / 2, y - size / 2, x + size / 2, y - size / 2, x + size, y - size);
      ctx.bezierCurveTo(x + size, y - size / 2, x + size, y + size / 2, x + size, y + size);
      ctx.bezierCurveTo(x + size / 2, y + size / 2, x - size / 2, y + size / 2, x - size, y + size);
      ctx.bezierCurveTo(x - size, y + size / 2, x - size, y - size / 2, x - size, y - size);
    }

    function drawQuatrefoil(x, y, size) {
      for (let i = 0; i < 4; i++) {
        const angle = (i * Math.PI) / 2;
        const cx = x + Math.cos(angle) * size / 2;
        const cy = y + Math.sin(angle) * size / 2;
        ctx.moveTo(cx + size / 2, cy);
        ctx.arc(cx, cy, size / 2, 0, Math.PI * 2);
      }
    }

    function drawLeaf(x, y, size) {
      ctx.moveTo(x, y - size);
      ctx.quadraticCurveTo(x + size, y - size / 2, x, y + size);
      ctx.quadraticCurveTo(x - size, y - size / 2, x, y - size);
    }

    function drawTeardrop(x, y, size) {
      ctx.moveTo(x, y - size);
      ctx.bezierCurveTo(x + size, y - size / 2, x + size, y + size / 2, x, y + size);
      ctx.bezierCurveTo(x - size, y + size / 2, x - size, y - size / 2, x, y - size);
    }

    function drawZigzag(x, y, size) {
      const points = 4;
      const width = size * 2;
      const height = size;
      ctx.moveTo(x - width / 2, y - height / 2);
      for (let i = 1; i <= points; i++) {
        const xPos = x - width / 2 + (i / points) * width;
        const yPos = i % 2 === 0 ? y - height / 2 : y + height / 2;
        ctx.lineTo(xPos, yPos);
      }
    }

    function drawChevron(x, y, size) {
      ctx.moveTo(x - size, y + size / 2);
      ctx.lineTo(x, y - size / 2);
      ctx.lineTo(x + size, y + size / 2);
    }

    function drawBrackets(x, y, size) {
      ctx.moveTo(x - size / 2, y - size);
      ctx.lineTo(x - size, y);
      ctx.lineTo(x - size / 2, y + size);
      ctx.moveTo(x + size / 2, y - size);
      ctx.lineTo(x + size, y);
      ctx.lineTo(x + size / 2, y + size);
    }

    function drawGrid(x, y, size) {
      const gridSize = 3;
      const cellSize = (size * 2) / gridSize;
      // Vertical lines
      for (let i = 0; i <= gridSize; i++) {
        const xPos = x - size + i * cellSize;
        ctx.moveTo(xPos, y - size);
        ctx.lineTo(xPos, y + size);
      }
      // Horizontal lines
      for (let i = 0; i <= gridSize; i++) {
        const yPos = y - size + i * cellSize;
        ctx.moveTo(x - size, yPos);
        ctx.lineTo(x + size, yPos);
      }
    }

    function drawIsogrid(x, y, size) {
      // Diamond/isometric grid pattern
      const step = size / 2;
      // Vertical diamonds
      ctx.moveTo(x, y - size);
      ctx.lineTo(x + size, y);
      ctx.lineTo(x, y + size);
      ctx.lineTo(x - size, y);
      ctx.closePath();
      // Interior cross
      ctx.moveTo(x - size, y);
      ctx.lineTo(x + size, y);
      ctx.moveTo(x, y - size);
      ctx.lineTo(x, y + size);
    }

    function drawHatch(x, y, size) {
      // Parallel diagonal lines
      const lines = 5;
      const spacing = (size * 2) / lines;
      for (let i = 0; i < lines; i++) {
        const offset = -size + i * spacing;
        ctx.moveTo(x + offset - size, y - size);
        ctx.lineTo(x + offset + size, y + size);
      }
    }

    function drawCrosshatch(x, y, size) {
      // Diagonal lines in both directions
      const lines = 4;
      const spacing = (size * 2) / lines;
      // Forward diagonal
      for (let i = 0; i < lines; i++) {
        const offset = -size + i * spacing;
        ctx.moveTo(x + offset - size, y - size);
        ctx.lineTo(x + offset + size, y + size);
      }
      // Backward diagonal
      for (let i = 0; i < lines; i++) {
        const offset = -size + i * spacing;
        ctx.moveTo(x + offset + size, y - size);
        ctx.lineTo(x + offset - size, y + size);
      }
    }

    function drawHexgrid(x, y, size) {
      // Hexagonal grid cell
      drawPolygon(x, y, 6, size);
      // Inner hexagons
      drawPolygon(x, y, 6, size / 2);
    }

    function drawBrickgrid(x, y, size) {
      // Brick/offset grid pattern
      const brickWidth = size;
      const brickHeight = size / 2;
      // Top brick
      ctx.rect(x - brickWidth / 2, y - size, brickWidth, brickHeight);
      // Bottom left brick
      ctx.rect(x - brickWidth, y - size + brickHeight, brickWidth, brickHeight);
      // Bottom right brick
      ctx.rect(x, y - size + brickHeight, brickWidth, brickHeight);
      // Bottom row
      ctx.rect(x - brickWidth / 2, y + brickHeight - size, brickWidth, brickHeight);
    }

    function drawInfinity(x, y, size) {
      // Infinity symbol (lemniscate) using two circles connected
      const radius = size * 0.5;
      const offset = size * 0.5;
      
      // Left loop
      ctx.arc(x - offset, y, radius, 0, Math.PI * 2);
      
      // Right loop
      ctx.moveTo(x + offset + radius, y);
      ctx.arc(x + offset, y, radius, 0, Math.PI * 2);
    }
    
    // Get mirrored points (for saving) based on mode
    function getMirroredPoints(points) {
      const segments = getMirroredSegments(points);
      // Flatten all segments into one array for export
      return segments.flat();
    }
    
    // Redraw everything
    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      strokes.forEach(stroke => {
        drawStroke(stroke);
      });
      if (currentStroke) drawStroke(currentStroke);
    }
    
    // Clear canvas
    document.getElementById('clearBtn').addEventListener('click', () => {
      strokes = [];
      currentStroke = null;
      currentShape = null; // Reset to line drawing mode
      redraw();
      showStatus('Cleared');
      closeFlyouts();
      menu.classList.remove('visible');
    });
    
    // Save drawing
    document.getElementById('sewBtn').addEventListener('click', () => {
      const now = new Date();
      const months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
      const dateStr = `${months[now.getMonth()]} ${now.getDate()}, ${now.getFullYear()}-${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
      const filename = `${dateStr}#${pad(counter, 4)}.txt`;
      
      // Expand strokes with mirrors
      const expandedStrokes = strokes.map(stroke => ({
        color: stroke.color,
        lineWidth: stroke.weight,
        points: getMirroredPoints(stroke.points)
      }));
      
      const data = {
        canvasWidth: canvas.width,
        canvasHeight: canvas.height,
        strokes: expandedStrokes
      };
      
      // Download
      const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      
      counter++;
      localStorage.setItem('sewCounter', counter.toString());
      
      showStatus(`Saved: ${filename}`, 3000);
      closeFlyouts();
      menu.classList.remove('visible');
    });
    
    function pad(num, size = 2) {
      return num.toString().padStart(size, '0');
    }
    
    function showStatus(msg, duration = 2000) {
      statusDiv.textContent = msg;
      statusDiv.classList.add('show');
      setTimeout(() => statusDiv.classList.remove('show'), duration);
    }
    
    // Show initial help
    setTimeout(() => {
      showStatus('Tap bottom-left corner for menu', 3000);
    }, 500);
    
    // Prevent scrolling/zooming (but allow two-finger rotation in shape mode)
    document.addEventListener('touchmove', (e) => {
      if (e.touches.length > 1 && !currentShape) e.preventDefault();
    }, {passive: false});
    
    // Request fullscreen on load (if supported)
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen().catch(() => {});
    } else if (document.documentElement.webkitRequestFullscreen) {
      document.documentElement.webkitRequestFullscreen().catch(() => {});
    }
    
    // Force scroll to hide URL bar on Kindle/mobile browsers
    window.addEventListener('load', () => {
      setTimeout(() => {
        window.scrollTo(0, 1);
      }, 100);
    });
    
    // Hide address bar on orientation change
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        window.scrollTo(0, 1);
      }, 100);
    });
  </script>
</body>
</html>
