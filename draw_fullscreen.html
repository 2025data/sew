<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Sew Fullscreen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#ffffff">
  <style>
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #fff;
      position: fixed;
    }
    #pad {
      display: block;
      width: 100vw;
      height: 100vh;
      touch-action: none;
      background: #fff;
      cursor: crosshair;
    }
    /* Hidden UI - shown only when tapping corner */
    #menu {
      position: fixed;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      border: 2px solid #000;
      padding: 8px;
      display: none;
      font-family: sans-serif;
      font-size: 14px;
      z-index: 1000;
    }
    #menu.visible {
      display: flex;
      flex-direction: row;
      gap: 8px;
      justify-content: space-around;
      align-items: center;
    }
    #menu button {
      font-size: 14px;
      padding: 10px 16px;
      border: 2px solid #000;
      background: #fff;
      cursor: pointer;
      white-space: nowrap;
      position: relative;
      overflow: hidden;
    }
    #menu button:active, #menu button.active {
      background: #ddd;
      border-color: #333;
    }
    
    /* Visual indicators on toggle buttons */
    .btn-indicator {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 1;
    }
    .btn-text {
      position: relative;
      z-index: 2;
      background: #fff;
      padding: 0 4px;
      display: inline-block;
    }
    #weightToggle .btn-text,
    #colorToggle .btn-text,
    #mirrorToggle .btn-text {
      background: rgba(255, 255, 255, 0.9);
      padding: 2px 6px;
      border-radius: 2px;
    }
    
    /* Flyout containers */
    .flyout-container {
      position: relative;
      display: inline-block;
    }
    .flyout {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-bottom: 8px;
      background: rgba(255,255,255,0.98);
      border: 2px solid #000;
      padding: 8px;
      display: none;
      flex-wrap: wrap;
      gap: 6px;
      max-width: 300px;
      justify-content: center;
    }
    .flyout.visible {
      display: flex;
    }
    
    /* Full-screen grid for line weights */
    #weightFlyout {
      position: fixed;
      top: 10px;
      left: 10px;
      right: 10px;
      bottom: 80px;
      max-width: 100%;
      transform: none;
      margin: 0;
      display: none;
      grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
      grid-auto-rows: 60px;
      overflow-y: auto;
    }
    #weightFlyout.visible {
      display: grid;
    }
    
    .flyout button {
      min-width: 40px;
      padding: 6px;
      font-size: 11px;
    }
    
    .weight-icon {
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    .weight-line {
      background: #000;
      width: 100%;
    }
    .weight-dots {
      position: absolute;
      top: 2px;
      left: 2px;
      right: 2px;
      bottom: 2px;
      pointer-events: none;
    }
    .weight-dot {
      position: absolute;
      width: 4px;
      height: 4px;
      background: #000;
      border-radius: 50%;
    }
    .color-swatch {
      width: 40px;
      height: 30px;
      border: 1px solid #000;
    }
    .status {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 4px 8px;
      font-size: 12px;
      font-family: monospace;
      border-radius: 4px;
      display: none;
      z-index: 999;
    }
    .status.show {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="pad"></canvas>
  
  <div id="menu">
    <button id="clearBtn">Clear</button>
    
    <div class="flyout-container">
      <button id="weightToggle">
        <canvas class="btn-indicator" id="weightIndicator" width="80" height="40"></canvas>
        <span class="btn-text">Line</span>
      </button>
      <div id="weightFlyout" class="flyout">
        <!-- Line weight buttons -->
      </div>
    </div>
    
    <div class="flyout-container">
      <button id="colorToggle">
        <div class="btn-indicator" id="colorIndicator"></div>
        <span class="btn-text">Color</span>
      </button>
      <div id="colorFlyout" class="flyout">
        <!-- Color buttons -->
      </div>
    </div>
    
    <div class="flyout-container">
      <button id="mirrorToggle">
        <canvas class="btn-indicator" id="mirrorIndicator" width="80" height="40"></canvas>
        <span class="btn-text">Mirror</span>
      </button>
      <div id="mirrorFlyout" class="flyout">
        <!-- Mirror buttons -->
      </div>
    </div>
    
    <button id="sewBtn">Sew</button>
  </div>
  
  <div class="status" id="status"></div>

  <script>
    // Fullscreen drawing app for Kindle
    const canvas = document.getElementById('pad');
    const ctx = canvas.getContext('2d');
    const menu = document.getElementById('menu');
    const statusDiv = document.getElementById('status');
    
    // Set canvas to full screen
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Drawing state
    let isDrawing = false;
    let strokes = [];
    let currentStroke = null;
    let lineWeight = 7;
    let color = '#000000';
    let mirrorMode = 'none';
    let counter = parseInt(localStorage.getItem('sewCounter') || '1');
    
    // Available options
    const weights = [1, 2, 3, 4, 5, 7, 9, 12, 15, 19, 24, 30, 38, 48, 60, 75, 85, 92, 97, 100];
    const colors = ['#000000', '#333333', '#666666', '#999999', '#CCCCCC', '#FFFFFF'];
    const mirrors = [
      {mode: 'none', label: '○'},
      {mode: 'bilateral', label: '◐'},
      {mode: 'quad', label: '◰'},
      {mode: 'radial', label: '✱'}
    ];
    
    // Flyout visibility tracking
    let activeFlyout = null;
    
    function closeFlyouts() {
      document.querySelectorAll('.flyout').forEach(f => f.classList.remove('visible'));
      activeFlyout = null;
    }
    
    // Update visual indicators
    function updateWeightIndicator() {
      const canvas = document.getElementById('weightIndicator');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const thickness = Math.min(lineWeight, 20);
      ctx.fillStyle = '#000';
      ctx.fillRect(0, (canvas.height - thickness) / 2, canvas.width, thickness);
    }
    
    function updateColorIndicator() {
      const indicator = document.getElementById('colorIndicator');
      indicator.style.backgroundColor = color;
    }
    
    function updateMirrorIndicator() {
      const canvas = document.getElementById('mirrorIndicator');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      
      if (mirrorMode === 'bilateral') {
        // Vertical line
        ctx.beginPath();
        ctx.moveTo(cx, 0);
        ctx.lineTo(cx, canvas.height);
        ctx.stroke();
      } else if (mirrorMode === 'quad') {
        // Vertical and horizontal lines
        ctx.beginPath();
        ctx.moveTo(cx, 0);
        ctx.lineTo(cx, canvas.height);
        ctx.moveTo(0, cy);
        ctx.lineTo(canvas.width, cy);
        ctx.stroke();
      } else if (mirrorMode === 'radial') {
        // 8 lines radiating from center
        for (let angle = 0; angle < 360; angle += 45) {
          const rad = angle * Math.PI / 180;
          const x2 = cx + Math.cos(rad) * cx;
          const y2 = cy + Math.sin(rad) * cy;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
      }
      // 'none' shows no lines
    }
    
    // Initialize indicators
    updateWeightIndicator();
    updateColorIndicator();
    updateMirrorIndicator();
    
    // Create line weight buttons in flyout
    const weightFlyout = document.getElementById('weightFlyout');
    weights.forEach(w => {
      const btn = document.createElement('button');
      btn.className = 'weight-btn';
      if (w === 7) btn.classList.add('active');
      
      const icon = document.createElement('div');
      icon.className = 'weight-icon';
      
      const line = document.createElement('div');
      line.className = 'weight-line';
      line.style.height = Math.min(w, 25) + 'px';
      
      icon.appendChild(line);
      
      // Add corner dots for weights > 20px
      if (w > 20) {
        const dotsContainer = document.createElement('div');
        dotsContainer.className = 'weight-dots';
        
        // Calculate number of dots (1-4 based on size)
        const numDots = Math.min(4, Math.ceil((w - 20) / 20));
        const positions = [
          {top: '0', left: '0'},
          {top: '0', right: '0'},
          {bottom: '0', left: '0'},
          {bottom: '0', right: '0'}
        ];
        
        for (let i = 0; i < numDots; i++) {
          const dot = document.createElement('div');
          dot.className = 'weight-dot';
          Object.assign(dot.style, positions[i]);
          dotsContainer.appendChild(dot);
        }
        
        icon.appendChild(dotsContainer);
      }
      
      btn.appendChild(icon);
      
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        lineWeight = w;
        document.querySelectorAll('.weight-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        updateWeightIndicator();
        showStatus(`Line: ${w}px`);
        closeFlyouts();
        menu.classList.remove('visible');
      });
      
      weightFlyout.appendChild(btn);
    });
    
    // Weight toggle button
    document.getElementById('weightToggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const flyout = document.getElementById('weightFlyout');
      if (activeFlyout === flyout) {
        closeFlyouts();
      } else {
        closeFlyouts();
        flyout.classList.add('visible');
        activeFlyout = flyout;
      }
    });
    
    // Create color buttons in flyout
    const colorFlyout = document.getElementById('colorFlyout');
    colors.forEach(c => {
      const btn = document.createElement('button');
      btn.className = 'color-btn';
      if (c === '#000000') btn.classList.add('active');
      
      const swatch = document.createElement('div');
      swatch.className = 'color-swatch';
      swatch.style.backgroundColor = c;
      
      btn.appendChild(swatch);
      
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        color = c;
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        updateColorIndicator();
        showStatus(`Color: ${c}`);
        closeFlyouts();
        menu.classList.remove('visible');
      });
      
      colorFlyout.appendChild(btn);
    });
    
    // Color toggle button
    document.getElementById('colorToggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const flyout = document.getElementById('colorFlyout');
      if (activeFlyout === flyout) {
        closeFlyouts();
      } else {
        closeFlyouts();
        flyout.classList.add('visible');
        activeFlyout = flyout;
      }
    });
    
    // Create mirror buttons in flyout
    const mirrorFlyout = document.getElementById('mirrorFlyout');
    mirrors.forEach(m => {
      const btn = document.createElement('button');
      btn.className = 'mirror-btn';
      btn.textContent = m.label;
      btn.style.fontSize = '20px';
      if (m.mode === 'none') btn.classList.add('active');
      
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        mirrorMode = m.mode;
        document.querySelectorAll('.mirror-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        updateMirrorIndicator();
        showStatus(`Mirror: ${m.mode}`);
        redraw();
        closeFlyouts();
        menu.classList.remove('visible');
      });
      
      mirrorFlyout.appendChild(btn);
    });
    
    // Mirror toggle button
    document.getElementById('mirrorToggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const flyout = document.getElementById('mirrorFlyout');
      if (activeFlyout === flyout) {
        closeFlyouts();
      } else {
        closeFlyouts();
        flyout.classList.add('visible');
        activeFlyout = flyout;
      }
    });
    
    // Menu toggle - tap bottom-left corner
    canvas.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      const x = touch.clientX;
      const y = touch.clientY;
      
      // Bottom-left corner (100x100px) toggles menu
      if (x < 100 && y > canvas.height - 100) {
        e.preventDefault();
        menu.classList.toggle('visible');
        return;
      }
      
      // If menu is open and tapping outside it, close menu
      if (menu.classList.contains('visible')) {
        menu.classList.remove('visible');
        return;
      }
      
      // Start drawing
      isDrawing = true;
      currentStroke = {
        points: [{x, y}],
        weight: lineWeight,
        color: color
      };
    }, {passive: false});
    
    canvas.addEventListener('touchmove', (e) => {
      if (!isDrawing || menu.classList.contains('visible')) return;
      e.preventDefault();
      
      const touch = e.touches[0];
      const x = touch.clientX;
      const y = touch.clientY;
      
      currentStroke.points.push({x, y});
      drawStroke(currentStroke);
    }, {passive: false});
    
    canvas.addEventListener('touchend', (e) => {
      if (!isDrawing) return;
      e.preventDefault();
      isDrawing = false;
      
      // If it was just a tap (single point), draw a dot
      if (currentStroke.points.length === 1) {
        const pt = currentStroke.points[0];
        const segments = getMirroredSegments([pt]);
        
        ctx.fillStyle = currentStroke.color;
        segments.forEach(seg => {
          seg.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, currentStroke.weight / 2, 0, Math.PI * 2);
            ctx.fill();
          });
        });
      }
      
      strokes.push(currentStroke);
      currentStroke = null;
    });
    
    // Draw a single stroke
    function drawStroke(stroke) {
      const segments = getMirroredSegments(stroke.points);
      
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = stroke.weight;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      // Draw each segment separately
      segments.forEach(points => {
        ctx.beginPath();
        points.forEach((pt, i) => {
          if (i === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        });
        ctx.stroke();
      });
    }
    
    // Get mirrored segments based on mode
    function getMirroredSegments(points) {
      if (mirrorMode === 'none') return [points];
      
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const segments = [points]; // Original stroke
      
      if (mirrorMode === 'bilateral') {
        // Mirror across vertical center
        segments.push(points.map(p => ({x: 2*cx - p.x, y: p.y})));
      } else if (mirrorMode === 'quad') {
        // Mirror across vertical, horizontal, and both
        segments.push(points.map(p => ({x: 2*cx - p.x, y: p.y})));
        segments.push(points.map(p => ({x: p.x, y: 2*cy - p.y})));
        segments.push(points.map(p => ({x: 2*cx - p.x, y: 2*cy - p.y})));
      } else if (mirrorMode === 'radial') {
        // Rotate around center at 45-degree intervals
        for (let angle = 45; angle < 360; angle += 45) {
          const rad = angle * Math.PI / 180;
          const cos_a = Math.cos(rad);
          const sin_a = Math.sin(rad);
          segments.push(points.map(p => {
            const dx = p.x - cx;
            const dy = p.y - cy;
            return {
              x: cx + dx * cos_a - dy * sin_a,
              y: cy + dx * sin_a + dy * cos_a
            };
          }));
        }
      }
      
      return segments;
    }
    
    // Get mirrored points (for saving) based on mode
    function getMirroredPoints(points) {
      const segments = getMirroredSegments(points);
      // Flatten all segments into one array for export
      return segments.flat();
    }
    
    // Redraw everything
    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      strokes.forEach(stroke => drawStroke(stroke));
      if (currentStroke) drawStroke(currentStroke);
    }
    
    // Clear canvas
    document.getElementById('clearBtn').addEventListener('click', () => {
      strokes = [];
      currentStroke = null;
      redraw();
      showStatus('Cleared');
      closeFlyouts();
      menu.classList.remove('visible');
    });
    
    // Save drawing
    document.getElementById('sewBtn').addEventListener('click', () => {
      const now = new Date();
      const months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
      const dateStr = `${months[now.getMonth()]} ${now.getDate()}, ${now.getFullYear()}-${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
      const filename = `${dateStr}#${pad(counter, 4)}.txt`;
      
      // Expand strokes with mirrors
      const expandedStrokes = strokes.map(stroke => ({
        color: stroke.color,
        lineWidth: stroke.weight,
        points: getMirroredPoints(stroke.points)
      }));
      
      const data = {
        canvasWidth: canvas.width,
        canvasHeight: canvas.height,
        strokes: expandedStrokes
      };
      
      // Download
      const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      
      counter++;
      localStorage.setItem('sewCounter', counter.toString());
      
      showStatus(`Saved: ${filename}`, 3000);
      closeFlyouts();
      menu.classList.remove('visible');
    });
    
    function pad(num, size = 2) {
      return num.toString().padStart(size, '0');
    }
    
    function showStatus(msg, duration = 2000) {
      statusDiv.textContent = msg;
      statusDiv.classList.add('show');
      setTimeout(() => statusDiv.classList.remove('show'), duration);
    }
    
    // Show initial help
    setTimeout(() => {
      showStatus('Tap bottom-left corner for menu', 3000);
    }, 500);
    
    // Prevent scrolling/zooming
    document.addEventListener('touchmove', (e) => {
      if (e.touches.length > 1) e.preventDefault();
    }, {passive: false});
    
    // Request fullscreen on load (if supported)
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen().catch(() => {});
    } else if (document.documentElement.webkitRequestFullscreen) {
      document.documentElement.webkitRequestFullscreen().catch(() => {});
    }
    
    // Force scroll to hide URL bar on Kindle/mobile browsers
    window.addEventListener('load', () => {
      setTimeout(() => {
        window.scrollTo(0, 1);
      }, 100);
    });
    
    // Hide address bar on orientation change
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        window.scrollTo(0, 1);
      }, 100);
    });
  </script>
</body>
</html>
