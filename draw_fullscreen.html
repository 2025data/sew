<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Sew Fullscreen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#ffffff">
  <style>
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #fff;
      position: fixed;
    }
    #pad {
      display: block;
      width: 100vw;
      height: 100vh;
      touch-action: none;
      background: #fff;
      cursor: crosshair;
    }
    /* Hidden UI - shown only when tapping corner */
    #menu {
      position: fixed;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      border: 2px solid #000;
      padding: 8px;
      display: none;
      font-family: sans-serif;
      font-size: 14px;
      z-index: 1000;
    }
    #menu.visible {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: space-around;
      align-items: center;
    }
    #menu button, #menu select {
      font-size: 16px;
      padding: 8px 12px;
      border: 1px solid #000;
      background: #fff;
      min-width: 60px;
    }
    #menu button:active {
      background: #ddd;
    }
    .status {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 4px 8px;
      font-size: 12px;
      font-family: monospace;
      border-radius: 4px;
      display: none;
      z-index: 999;
    }
    .status.show {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="pad"></canvas>
  
  <div id="menu">
    <button id="clearBtn">Clear</button>
    
    <select id="lineWeight">
      <option value="1">1px</option>
      <option value="2">2px</option>
      <option value="4">4px</option>
      <option value="7" selected>7px</option>
      <option value="12">12px</option>
      <option value="20">20px</option>
      <option value="33">33px</option>
      <option value="55">55px</option>
      <option value="92">92px</option>
      <option value="153">153px</option>
      <option value="300">300px</option>
    </select>
    
    <select id="color">
      <option value="#000000" selected>Black</option>
      <option value="#333333">Dark Gray</option>
      <option value="#666666">Gray</option>
      <option value="#999999">Light Gray</option>
      <option value="#CCCCCC">Lighter</option>
      <option value="#FFFFFF">White</option>
    </select>
    
    <select id="mirror">
      <option value="none" selected>No Mirror</option>
      <option value="bilateral">Bilateral</option>
      <option value="quad">Quad</option>
      <option value="radial">Radial (8)</option>
    </select>
    
    <button id="sewBtn">Sew</button>
  </div>
  
  <div class="status" id="status"></div>

  <script>
    // Fullscreen drawing app for Kindle
    const canvas = document.getElementById('pad');
    const ctx = canvas.getContext('2d');
    const menu = document.getElementById('menu');
    const statusDiv = document.getElementById('status');
    
    // Set canvas to full screen
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Drawing state
    let isDrawing = false;
    let strokes = [];
    let currentStroke = null;
    let lineWeight = 7;
    let color = '#000000';
    let mirrorMode = 'none';
    let counter = parseInt(localStorage.getItem('sewCounter') || '1');
    
    // Settings - auto-close menu on change
    document.getElementById('lineWeight').addEventListener('change', (e) => {
      lineWeight = parseInt(e.target.value);
      showStatus(`Line: ${lineWeight}px`);
      menu.classList.remove('visible');
    });
    
    document.getElementById('color').addEventListener('change', (e) => {
      color = e.target.value;
      showStatus(`Color: ${color}`);
      menu.classList.remove('visible');
    });
    
    document.getElementById('mirror').addEventListener('change', (e) => {
      mirrorMode = e.target.value;
      showStatus(`Mirror: ${mirrorMode}`);
      redraw();
      menu.classList.remove('visible');
    });
    
    // Menu toggle - tap bottom-left corner
    canvas.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      const x = touch.clientX;
      const y = touch.clientY;
      
      // Bottom-left corner (100x100px) toggles menu
      if (x < 100 && y > canvas.height - 100) {
        e.preventDefault();
        menu.classList.toggle('visible');
        return;
      }
      
      // If menu is open and tapping outside it, close menu
      if (menu.classList.contains('visible')) {
        menu.classList.remove('visible');
        return;
      }
      
      // Start drawing
      isDrawing = true;
      currentStroke = {
        points: [{x, y}],
        weight: lineWeight,
        color: color
      };
    }, {passive: false});
    
    canvas.addEventListener('touchmove', (e) => {
      if (!isDrawing || menu.classList.contains('visible')) return;
      e.preventDefault();
      
      const touch = e.touches[0];
      const x = touch.clientX;
      const y = touch.clientY;
      
      currentStroke.points.push({x, y});
      drawStroke(currentStroke);
    }, {passive: false});
    
    canvas.addEventListener('touchend', (e) => {
      if (!isDrawing) return;
      e.preventDefault();
      isDrawing = false;
      
      // If it was just a tap (single point), draw a dot
      if (currentStroke.points.length === 1) {
        const pt = currentStroke.points[0];
        const points = getMirroredPoints([pt]);
        
        ctx.fillStyle = currentStroke.color;
        points.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, currentStroke.weight / 2, 0, Math.PI * 2);
          ctx.fill();
        });
      }
      
      strokes.push(currentStroke);
      currentStroke = null;
    });
    
    // Draw a single stroke
    function drawStroke(stroke) {
      const points = getMirroredPoints(stroke.points);
      
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = stroke.weight;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      ctx.beginPath();
      points.forEach((pt, i) => {
        if (i === 0) ctx.moveTo(pt.x, pt.y);
        else ctx.lineTo(pt.x, pt.y);
      });
      ctx.stroke();
    }
    
    // Get mirrored points based on mode
    function getMirroredPoints(points) {
      if (mirrorMode === 'none') return points;
      
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const result = [...points];
      
      if (mirrorMode === 'bilateral') {
        points.forEach(p => {
          result.push({x: 2*cx - p.x, y: p.y});
        });
      } else if (mirrorMode === 'quad') {
        points.forEach(p => {
          result.push({x: 2*cx - p.x, y: p.y});
          result.push({x: p.x, y: 2*cy - p.y});
          result.push({x: 2*cx - p.x, y: 2*cy - p.y});
        });
      } else if (mirrorMode === 'radial') {
        points.forEach(p => {
          const dx = p.x - cx;
          const dy = p.y - cy;
          for (let angle = 45; angle < 360; angle += 45) {
            const rad = angle * Math.PI / 180;
            const cos_a = Math.cos(rad);
            const sin_a = Math.sin(rad);
            result.push({
              x: cx + dx * cos_a - dy * sin_a,
              y: cy + dx * sin_a + dy * cos_a
            });
          }
        });
      }
      
      return result;
    }
    
    // Redraw everything
    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      strokes.forEach(stroke => drawStroke(stroke));
      if (currentStroke) drawStroke(currentStroke);
    }
    
    // Clear canvas
    document.getElementById('clearBtn').addEventListener('click', () => {
      strokes = [];
      currentStroke = null;
      redraw();
      showStatus('Cleared');
      menu.classList.remove('visible');
    });
    
    // Save drawing
    document.getElementById('sewBtn').addEventListener('click', () => {
      const now = new Date();
      const months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
      const dateStr = `${months[now.getMonth()]} ${now.getDate()}, ${now.getFullYear()}-${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
      const filename = `${dateStr}#${pad(counter, 4)}.txt`;
      
      // Expand strokes with mirrors
      const expandedStrokes = strokes.map(stroke => ({
        color: stroke.color,
        lineWidth: stroke.weight,
        points: getMirroredPoints(stroke.points)
      }));
      
      const data = {
        canvasWidth: canvas.width,
        canvasHeight: canvas.height,
        strokes: expandedStrokes
      };
      
      // Download
      const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      
      counter++;
      localStorage.setItem('sewCounter', counter.toString());
      
      showStatus(`Saved: ${filename}`, 3000);
      menu.classList.remove('visible');
    });
    
    function pad(num, size = 2) {
      return num.toString().padStart(size, '0');
    }
    
    function showStatus(msg, duration = 2000) {
      statusDiv.textContent = msg;
      statusDiv.classList.add('show');
      setTimeout(() => statusDiv.classList.remove('show'), duration);
    }
    
    // Show initial help
    setTimeout(() => {
      showStatus('Tap bottom-left corner for menu', 3000);
    }, 500);
    
    // Prevent scrolling/zooming
    document.addEventListener('touchmove', (e) => {
      if (e.touches.length > 1) e.preventDefault();
    }, {passive: false});
    
    // Request fullscreen on load (if supported)
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen().catch(() => {});
    } else if (document.documentElement.webkitRequestFullscreen) {
      document.documentElement.webkitRequestFullscreen().catch(() => {});
    }
    
    // Force scroll to hide URL bar on Kindle/mobile browsers
    window.addEventListener('load', () => {
      setTimeout(() => {
        window.scrollTo(0, 1);
      }, 100);
    });
    
    // Hide address bar on orientation change
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        window.scrollTo(0, 1);
      }, 100);
    });
  </script>
</body>
</html>
